# -*- coding: utf-8 -*-
"""Levenshtein distance

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WygRSyrtFJbYe_b5dTY-NXbMUlhs7cUY

Lavenshtein distance implementaiton can be found anywhere on the web.
And that implementation would be really easy.
I see a very nieve approch with better time complexity to get the desired result, hence implemented this way.
"""

import pandas as pd

data = pd.read_csv('20210103_hundenamen.csv')

data.head()

word = "Luca"

mask = (data['HUNDENAME'].str.len() >=3 ) & (data['HUNDENAME'].str.len() <= 5)
df = data.loc[mask]

def remove_ith(string, i):
  return string[ : i] + string[i+1: ]

list_of_possible_words = []
for i in range(len(word)):
  list_of_possible_words.append(remove_ith(word,i))

# We dont actually need to implement the Levenshtein distance since d = 1
# 3 cases: 
# len=5: deletion of 1 char
# len=3: insertion of 1 char
# len=4: replacement of 1 char

df_5 = df[df['HUNDENAME'].str.len() == 5]
l1 = df_5[df_5['HUNDENAME'].str.contains(word)]['HUNDENAME'].to_list()

# Luca -> 3 character word possible would be Luc, Lca, Lua, uca
df_3 = df[df['HUNDENAME'].str.len() == 3]
l2 = df_3[df_3['HUNDENAME'].isin(list_of_possible_words)]['HUNDENAME'].to_list()

# 3 characters must match in the given order Luca
# we can do is, remove 1st character and find all 3 letter matches. then removing only 2nd letter and find the number of 3 letter mathces and so on.
df_4 = df[df['HUNDENAME'].str.len() == 4]
l3 = []
for i in range(len(word)):
  df_4['HUNDENAME2'] = df_4['HUNDENAME'].apply(lambda x: remove_ith(x, i))
  l = df_4[df_4['HUNDENAME2'].isin(list_of_possible_words)]['HUNDENAME'].to_list()
  l3 = l3 + l

all_list = list(set(l1 + l2 + l3))

print(', '.join(all_list))

